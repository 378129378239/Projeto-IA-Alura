# -*- coding: utf-8 -*-
"""c-pia-de-untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/gist/378129378239/50aa8ee449198ca9193b32618106a485/c-pia-de-untitled1.ipynb
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip -q install google-genai

!pip install google-generativeai

# Configura a API Key do Google Gemini

import os
from google.colab import userdata

os.environ["GOOGLE_API_KEY"] = userdata.get('GOOGLE_API_KEY')

# Configura o cliente da SDK do Gemini

from google import genai

client = genai.Client()

MODEL_ID = "gemini-2.0-flash"

# Pergunta ao Gemini uma informação mais recente que seu conhecimento

from IPython.display import HTML, Markdown

# Perguntar pro modelo quando é a próxima imersão de IA ###############################################
resposta = client.models.generate_content(
    model=MODEL_ID,
    contents='Quando é a próxima Imersão IA com Google Gemini da Alura?',
)

# Exibe a resposta na tela
display(Markdown(f"Resposta:\n {resposta.text}"))

# Pergunta ao Gemini uma informação utilizando a busca do Google como contexto

response = client.models.generate_content(model=MODEL_ID,
    contents='Quando é a próxima Imersão IA com Google Gemini da Alura?',
    config={"tools": [{"google_search": {}}]}
    )


# Exibe a resposta na tela
display(Markdown(f"Resposta:\n {response.text}"))

# Exibe a busca
print(f"Busca realizada: {response.candidates[0].grounding_metadata.web_search_queries}")
# Exibe as URLs nas quais ele se baseou
print(f"Páginas utilizadas na resposta: {', '.join([site.web.title for site in response.candidates[0].grounding_metadata.grounding_chunks])}")
print()
display(HTML(response.candidates[0].grounding_metadata.search_entry_point.rendered_content))

# Instalar Framework ADK de agentes do Google ################################################
!pip install -q google-adk

from google.adk.agents import Agent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools import google_search
from google.genai import types  # Para criar conteúdos (Content e Part)
from datetime import date
import textwrap # Para formatar melhor a saída de texto
from IPython.display import display, Markdown # Para exibir texto formatado no Colab
import requests # Para fazer requisições HTTP
import warnings

warnings.filterwarnings("ignore")

import json
import os
import datetime
import uuid
from google.colab import userdata # Para buscar a API Key no Colab
from google import genai # SDK do Gemini
from IPython.display import display, Markdown # Para exibir texto formatado no Colab
import textwrap # Para formatar melhor a saída de texto

# --- Configuração da API Key e Cliente Gemini (INÍCIO) ---
# Esta parte é para rodar no Google Colab. Se for rodar localmente,
# configure a API Key de outra forma (ex: variável de ambiente).
try:
    os.environ["GOOGLE_API_KEY"] = userdata.get('GOOGLE_API_KEY') # Substitua pelo nome da sua Secret
except userdata.SecretNotFoundError as e:
    print(f"Secret não encontrada: {e}. Por favor, configure a GOOGLE_API_KEY no Colab.")
    exit()

MODEL_ID = "gemini-2.0-flash" # Usando um modelo que suporte tools
# --- Configuração da API Key e Cliente Gemini (FIM) ---

# Nome do arquivo para armazenar os dados do usuário
DATA_FILE = "quantizador_user_data.json"
USER_ID_FILE = "quantizador_user_id.txt"

# URLs fornecidas para base de conhecimento dos agentes
PROVIDED_URLS = [
    "https://www.psitto.com.br/blog/tipos-terapia/",
    "https://www.paho.org/pt/noticias/25-6-2024-mais-tres-milhoes-pessoas-morrem-cada-ano-maioria-homens-devido-ao-uso-alcool-e",
    "https://www.gov.br/saude/pt-br/composicao/saes/desmad/raps/caps",
    "https://www.gov.br/mds/pt-br/noticias-e-conteudos/publicacoes/desenvolvimento-social/cartilha_como-ajudar-uma-pessoa-dependente-de-drogas.pdf",
    "https://www.scielo.br/j/pe/a/4RMNrWKNpxxyzJ5FLZZgFJD/",
    "https://subpav.org/aps/uploads/publico/repositorio/guia_de_referencia_rapida_-_alcool_e_outras_drogas_(1).pdf"
]
URLS_STRING = "\n".join(PROVIDED_URLS) # String com as URLs para passar aos agentes

# --- Funções Auxiliares para Agentes (ADK simulado com chamadas diretas) ---

def call_generative_model(prompt_text, use_google_search=False):
    """
    Função simplificada para chamar o modelo generativo do Gemini.
    Emula a ideia de um 'agente' ADK, mas com chamada direta à API.
    """
    try:
        model = genai.GenerativeModel(MODEL_ID)
        tools = [{"google_search": {}}] if use_google_search else None
        response = model.generate_content(prompt_text, tools=tools if tools else None) # type: ignore
        # Verifica se há texto na resposta antes de tentar acessá-lo
        if response.candidates and response.candidates[0].content.parts:
            return response.text
        else:
            return "O modelo não retornou um texto válido."
    except Exception as e:
        return f"Erro ao chamar o modelo generativo: {e}"

def to_markdown(text):
  """Função para formatar texto para exibição em Markdown no Colab."""
  text = text.replace('•', '  *')
  return Markdown(textwrap.indent(text, '> ', predicate=lambda _: True))

# --- Agente 1: Formulador de Perguntas ---
def agente_formulador_perguntas(tipo_vicio):
    """
    Agente responsável por formular de 3 a 5 perguntas de Sim/Não
    para o diário do usuário, baseadas no tipo de vício e nas URLs fornecidas.
    """
    # Instrução para o agente formular perguntas.
    prompt = f"""
    Você é um assistente especializado em saúde mental e vícios.
    Sua tarefa é formular de 3 a 5 perguntas SIMPLES e DIRETAS (com respostas apenas 'sim' ou 'não')
    para um diário de um usuário que está tentando superar o seguinte hábito/vício: '{tipo_vicio}'.

    BASEIE suas perguntas nas informações contidas nos seguintes recursos:
    {URLS_STRING}

    As perguntas devem ajudar o usuário a refletir sobre seu dia em relação a este hábito.
    Exemplos de estrutura de pergunta:
    - 'Hoje você sentiu uma forte vontade de {tipo_vicio}?'
    - 'Você conseguiu aplicar alguma técnica para lidar com a vontade de {tipo_vicio} hoje?'
    - 'Você se envolveu em atividades que te ajudaram a não pensar em {tipo_vicio}?'

    Retorne APENAS a lista de perguntas, uma por linha, sem numeração ou marcadores.
    Não adicione introduções ou conclusões.
    """
    # Chama o modelo generativo (simulando o agente).
    perguntas_geradas = call_generative_model(prompt)
    # Processa a string de perguntas em uma lista.
    return [p.strip() for p in perguntas_geradas.split('\n') if p.strip()]

# --- Agente 2: Gerador de Feedback ---
def agente_gerador_feedback(tipo_vicio, respostas_diario_formatadas, streak_dias):
    """
    Agente responsável por gerar mensagens de suporte, apoio e indicações
    baseado nas respostas do usuário, tipo de vício e URLs.
    """
    # Instrução para o agente gerar feedback.
    prompt = f"""
    Você é um assistente de apoio empático e informativo, especializado em ajudar pessoas
    que estão lidando com o vício de '{tipo_vicio}'.
    O usuário está em uma sequência de {streak_dias} dias sem praticar o vício (se streak_dias > 0).
    As últimas respostas do diário do usuário foram:
    {respostas_diario_formatadas}

    Sua tarefa é gerar uma mensagem de feedback que inclua:
    1.  Suporte e apoio emocional, reconhecendo o esforço do usuário (seja ele qual for).
    2.  Se o usuário teve recaídas, ofereça palavras de encorajamento e não julgamento.
    3.  Se o usuário está indo bem (streak > 0), celebre a conquista.
    4.  Indicações GERAIS de onde ele pode buscar mais informações ou ajuda profissional,
        baseando-se principalmente nos seguintes recursos:
        {URLS_STRING}
        (Ex: "Você pode encontrar informações sobre X no site da OPAS ou procurar um CAPS próximo.")
    5.  Uma mensagem motivacional curta.

    Seja breve, direto, empático e construtivo. Use uma linguagem acolhedora.
    Finalize SEMPRE recomendando a busca por um profissional de saúde (psicólogo, terapeuta, médico).
    Não faça perguntas. Apenas forneça o feedback.
    """
    # Chama o modelo generativo (simulando o agente).
    return call_generative_model(prompt, use_google_search=True) # Pode usar search para complementar

# --- Funções LGPD e Gerenciamento de Dados (semelhantes à versão anterior) ---
def display_consent_and_terms():
    print("\n--- Bem-vindo ao Quantizador de Ações Assistido por IA ---") # Título do app.
    print("Este aplicativo te ajudará a acompanhar seus hábitos e progresso com o auxílio de IA.")
    print("\n[INFORMAÇÃO IMPORTANTE - LGPD e DIRETRIZES DO APP]") # Seção de informações importantes.
    print("1. Seus dados são tratados com confidencialidade.")
    print("2. Não coletamos informações pessoais diretas como nome ou e-mail.")
    print("3. As informações sobre seus hábitos (DADOS SENSÍVEIS) e suas respostas ao diário")
    print("   serão processadas por modelos de Inteligência Artificial do Google para gerar perguntas e feedbacks personalizados DENTRO DO APP.")
    print("4. Nenhum dado que permita te identificar diretamente será enviado para a IA sem sua ação explícita e consentimento para tal.")
    print("   As interações com a IA são baseadas no tipo de vício que você informar e nas suas respostas anônimas ao diário.")
    print("5. Seu progresso é associado a um identificador único gerado para este 'dispositivo' (simulado).")
    print("6. Recomendamos fortemente o acompanhamento terapêutico profissional. Este app é uma ferramenta de suporte, não um substituto.")
    print("7. Para mais detalhes, consulte nossos Termos de Uso e Política de Privacidade (simulados).")

    while True:
        consent = input("\nVocê concorda com os termos, incluindo o uso de IA para perguntas e feedbacks, e deseja continuar? (s/n): ").strip().lower()
        if consent == 's':
            print("Obrigado por concordar!")
            return True # Retorna True se o usuário consentir.
        elif consent == 'n':
            print("Entendido. O aplicativo será encerrado.")
            return False # Retorna False se o usuário não consentir.
        else:
            print("Opção inválida. Por favor, digite 's' para sim ou 'n' para não.")

def get_user_id():
    """Obtém ou gera um ID de usuário único."""
    if os.path.exists(USER_ID_FILE):
        with open(USER_ID_FILE, "r") as f:
            user_id = f.read().strip() # Lê o ID do arquivo.
    else:
        user_id = str(uuid.uuid4()) # Gera um novo ID.
        with open(USER_ID_FILE, "w") as f:
            f.write(user_id) # Salva o novo ID.
        print(f"\nUm ID anônimo foi gerado para você.")
    return user_id

def load_user_data(user_id):
    """Carrega os dados do usuário de um arquivo JSON."""
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r") as f:
            try:
                all_data = json.load(f) # Carrega todos os dados.
                return all_data.get(user_id, {"vice_info": {}, "relatos": [], "streaks": 0, "perguntas_diario": []}) # Retorna dados do usuário ou padrão.
            except json.JSONDecodeError:
                return {"vice_info": {}, "relatos": [], "streaks": 0, "perguntas_diario": []} # Retorna padrão em caso de erro.
    return {"vice_info": {}, "relatos": [], "streaks": 0, "perguntas_diario": []} # Retorna padrão se arquivo não existir.

def save_user_data(user_id, data):
    """Salva os dados do usuário em um arquivo JSON."""
    all_data = {}
    if os.path.exists(DATA_FILE) and os.path.getsize(DATA_FILE) > 0:
        with open(DATA_FILE, "r") as f:
            try:
                all_data = json.load(f) # Carrega dados existentes.
            except json.JSONDecodeError:
                all_data = {}
    all_data[user_id] = data # Atualiza/adiciona dados do usuário.
    with open(DATA_FILE, "w") as f:
        json.dump(all_data, f, indent=4) # Salva no arquivo JSON.

# --- Funções Principais do App (Adaptadas) ---

def initial_setup(data, user_id_for_agent):
    """Coleta informações iniciais sobre o vício do usuário e gera perguntas iniciais."""
    if not data.get("vice_info") or not data["vice_info"].get("tipo_vicio"):
        print("\n--- Configuração Inicial ---")
        tipo_vicio = input("Qual hábito/vício você gostaria de acompanhar? (ex: fumar, consumo de álcool): ").strip()
        data["vice_info"]["tipo_vicio"] = tipo_vicio # Armazena tipo de vício.
        # A parte de custo pode ser mantida ou simplificada
        try:
            data["vice_info"]["custo_estimado_por_unidade"] = float(input(f"Qual o custo estimado de uma 'unidade' desse hábito (ex: um cigarro, uma dose)? R$ ").replace(',','.'))
            data["vice_info"]["unidades_por_dia_anterior"] = int(input(f"Quantas 'unidades' desse hábito você costumava consumir por dia antes de decidir mudar? "))
        except ValueError:
            print("Valores de custo/quantidade inválidos. Feedbacks financeiros podem ser limitados.")
            data["vice_info"]["custo_estimado_por_unidade"] = 0
            data["vice_info"]["unidades_por_dia_anterior"] = 0

        print("Gerando perguntas personalizadas para seu diário...")
        # Usa o agente para formular as perguntas do diário.
        data["perguntas_diario"] = agente_formulador_perguntas(tipo_vicio)
        if not data["perguntas_diario"]:
            print("Não foi possível gerar as perguntas. Usando perguntas padrão.")
            # Perguntas padrão caso o agente falhe
            data["perguntas_diario"] = [
                f"Hoje você praticou '{tipo_vicio}'?",
                "Você se sentiu ansioso(a) ou com gatilhos para o vício hoje?",
                "Você realizou alguma atividade alternativa para evitar o vício?",
                "Você se hidratou bem hoje?",
                "Você se sentiu orgulhoso(a) de alguma pequena vitória hoje?"
            ]
        else:
            print("Perguntas do diário geradas!")
        save_user_data(user_id_for_agent, data) # Salva os dados após a configuração.
        print("Configuração inicial concluída!")
    return data

def record_daily_entry(data, user_id_for_agent):
    """Registra um novo relato/questionário do usuário com perguntas geradas pela IA."""
    print(f"\n--- Relato do Dia: {datetime.date.today()} ---")
    relato_atual = {"data": str(datetime.date.today()), "respostas": {}} # Dicionário para o relato.
    tipo_vicio = data.get("vice_info", {}).get("tipo_vicio", "o hábito")

    # Se não houver perguntas personalizadas, gera ou usa padrão
    if not data.get("perguntas_diario"):
        print("Gerando perguntas para o diário...")
        data["perguntas_diario"] = agente_formulador_perguntas(tipo_vicio)
        if not data["perguntas_diario"]: # Fallback
             data["perguntas_diario"] = [f"Hoje você praticou '{tipo_vicio}'?", "Você se sentiu ansioso(a) hoje?"]

    print("Responda com 's' para sim ou 'n' para não:")
    praticou_vicio_hoje = False # Flag para controlar o streak
    for i, pergunta_texto in enumerate(data["perguntas_diario"]):
        while True:
            resposta = input(f"{i+1}. {pergunta_texto} (s/n): ").strip().lower()
            if resposta in ['s', 'n']:
                relato_atual["respostas"][pergunta_texto] = (resposta == 's') # Armazena True para 's', False para 'n'.
                # Verifica se a primeira pergunta é sobre ter praticado o vício e se a resposta foi sim
                if i == 0 and (pergunta_texto.lower().startswith(f"hoje você praticou '{tipo_vicio.lower()}'") or "praticou" in pergunta_texto.lower()) and (resposta == 's'):
                    praticou_vicio_hoje = True
                break
            else:
                print("Resposta inválida.")

    if praticou_vicio_hoje:
        data["streaks"] = 0 # Reseta o streak.
        try:
            quantidade = int(input(f"Qual a quantidade de '{tipo_vicio}' hoje? (unidades): "))
            relato_atual["quantidade_vicio_dia"] = quantidade # Armazena quantidade se praticou.
        except ValueError:
            print("Quantidade inválida. Será registrado como 0.")
            relato_atual["quantidade_vicio_dia"] = 0
    else:
        data["streaks"] = data.get("streaks", 0) + 1 # Incrementa o streak.
        print(f"Parabéns! Você está há {data['streaks']} dia(s) em sequência sem {tipo_vicio}!")
        relato_atual["quantidade_vicio_dia"] = 0

    data["relatos"].append(relato_atual) # Adiciona o relato.
    save_user_data(user_id_for_agent, data) # Salva os dados.
    print("Relato salvo!")
    return data

def show_feedback(data):
    """Exibe feedbacks gerados pela IA."""
    print("\n--- Seu Feedback Personalizado ---")
    relatos = data.get("relatos", [])
    if not relatos:
        print("Ainda não há relatos para gerar um feedback.")
        return

    tipo_vicio = data.get("vice_info", {}).get("tipo_vicio", "seu hábito")
    streak = data.get("streaks", 0)

    # Formata as últimas N respostas para enviar ao agente (ex: últimas 3)
    ultimos_relatos_formatados = []
    for r in relatos[-3:]: # Pega os últimos 3 relatos
        respostas_formatadas = f"Data: {r['data']}\n"
        for pergunta, resposta in r.get("respostas", {}).items():
            respostas_formatadas += f"  - {pergunta}: {'Sim' if resposta else 'Não'}\n"
        if "quantidade_vicio_dia" in r:
            respostas_formatadas += f"  - Quantidade de '{tipo_vicio}' (se aplicável): {r['quantidade_vicio_dia']}\n"
        ultimos_relatos_formatados.append(respostas_formatadas)

    # Chama o agente para gerar o feedback.
    feedback_gerado = agente_gerador_feedback(tipo_vicio, "\n".join(ultimos_relatos_formatados), streak)
    display(to_markdown(feedback_gerado)) # Exibe o feedback formatado.

    # Adiciona cálculo simples de economia (pode ser mantido do exemplo anterior)
    custo_unidade = data.get("vice_info", {}).get("custo_estimado_por_unidade", 0)
    unidades_antigas_dia = data.get("vice_info", {}).get("unidades_por_dia_anterior", 0)
    if custo_unidade > 0 and unidades_antigas_dia > 0:
        total_unidades_atuais = sum(r.get("quantidade_vicio_dia", 0) for r in relatos)
        total_unidades_evitadas = (unidades_antigas_dia * len(relatos)) - total_unidades_atuais
        if total_unidades_evitadas > 0:
            economia = total_unidades_evitadas * custo_unidade
            print(f"\n[ECONOMIA ESTIMADA]: Você evitou aproximadamente {total_unidades_evitadas} unidades de '{tipo_vicio}' desde que começou a registrar.")
            print(f"Isso representa uma economia estimada de R$ {economia:.2f}!")


def show_therapeutic_approaches():
    """Mostra informações sobre abordagens terapêuticas (mantido)."""
    print("\n--- Abordagens Terapêuticas na Psicologia ---")
    print("1.  **Terapia Cognitivo-Comportamental (TCC):** Foca em identificar e modificar padrões de pensamento e comportamento.")
    print("2.  **Psicanálise:** Busca entender as causas inconscientes dos comportamentos.")
    print("3.  **Terapia Humanista/Existencial (Gestalt, ACP):** Enfatiza o crescimento pessoal e a autoconsciência.")
    print("Encontre mais informações e clínicas nos seguintes locais (exemplos):") # Informa sobre os locais de busca.
    print("- CAPS (Centros de Atenção Psicossocial): procure o mais próximo em sua cidade (gov.br/saude).")
    print("- Clínicas de psicologia e terapeutas especializados em dependência.")
    print("- Grupos de apoio como Alcoólicos Anônimos (AA) ou Narcóticos Anônimos (NA).")
    print("Lembre-se: Este app NÃO substitui o acompanhamento profissional.")


def display_main_menu():
    """Exibe o menu principal."""
    print("\n--- Menu Principal Quantizador Assistido ---")
    print("1. Registrar relato diário")
    print("2. Ver meu feedback personalizado")
    print("3. Informações sobre abordagens terapêuticas")
    print("4. Gerar novas perguntas para o diário (experimental)")
    print("5. Sair")
    return input("Escolha uma opção: ") # Retorna a escolha do usuário.

# --- Fluxo Principal do Aplicativo ---
if __name__ == "__main__":
    if not display_consent_and_terms(): # Pede consentimento.
        exit() # Sai se não consentido.

    USER_ID = get_user_id() # Obtém/Cria ID do usuário.
    user_data = load_user_data(USER_ID) # Carrega dados.

    if not user_data.get("vice_info") or not user_data["vice_info"].get("tipo_vicio") or not user_data.get("perguntas_diario"):
        user_data = initial_setup(user_data, USER_ID) # Configuração inicial se necessário.

    while True:
        choice = display_main_menu() # Exibe menu.

        if choice == '1':
            user_data = record_daily_entry(user_data, USER_ID) # Registra relato.
        elif choice == '2':
            show_feedback(user_data) # Mostra feedback.
        elif choice == '3':
            show_therapeutic_approaches() # Mostra info de terapias.
        elif choice == '4':
            tipo_vicio_atual = user_data.get("vice_info", {}).get("tipo_vicio")
            if tipo_vicio_atual:
                print("Gerando novas perguntas para seu diário...")
                novas_perguntas = agente_formulador_perguntas(tipo_vicio_atual) # Gera novas perguntas.
                if novas_perguntas:
                    user_data["perguntas_diario"] = novas_perguntas
                    save_user_data(USER_ID, user_data) # Salva as novas perguntas.
                    print("Novas perguntas do diário foram geradas e salvas!")
                else:
                    print("Não foi possível gerar novas perguntas no momento.")
            else:
                print("Configure o tipo de vício primeiro (reinicie o app ou implemente uma opção de reconfiguração).")
        elif choice == '5':
            print("Obrigado por usar o Quantizador Assistido! Até a próxima.")
            break # Sai do loop.
        else:
            print("Opção inválida. Tente novamente.")